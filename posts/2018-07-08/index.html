<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="../../katex/katex.min.css">
    <script src="../../katex/katex.min.js"></script>
    <script src="../../katex/contrib/auto-render.min.js"></script>
    <script src="../../lib/math.min.js"></script>
	 <style>
		body { padding-left: 40px; max-width: 50em; }
		.code { white-space: pre; display: block; }
		td { padding-left: 30px; }
	 </style>
  </head>
  <body style="width: 800px">
	 <h1>Towards a Judgmental Reconstruction of Dynamic Logic</h1>
	 <a href="https://twitter.com/chrisamaphone">Chris Martens</a>
	 posed a question the other day of what kind of nice
	 constructive/judgmental sense can be made of Dynamic Logic, and I
	 thought I'd write down my thoughts on at least how I think the
	 low-hanging-fruit part of it ought to go. Naturally, I'll use my
	 favorite everything-looks-like-nails hammer, which is taking
	 advantage of focusing to turn semantic clauses &mdash; as long as
	 you guess the correct "constructive semantics" clauses &mdash;
	 more or less automatically into inference rules.

	 <h2>Refresher on Dynamic/Epistemic Logic</h2>
	 Dynamic logic is a modal logic that I'd heard a
	 little bit about in the past, but I was never really intimately
	 familiar with it. Possibly this is because I hadn't encountered a
	 presentation of it in the style below, so it just seemed like one
	 of those "oh, it's kind of an interesting logic but it seems like
	 a big bag of classical axioms, so I don't really know what sense
	 it makes" kinds of things. The reference I'm using for some of its
	 features is the paper chris referred me
	 to, <a href="http://www.vub.ac.be/CLWF/SS/BER.pdf">A Logic for
	 Suspicious Players: Epistemic Actions and Belief-Updates in
	 Games</a>. I can divide the logical features going on in this paper into three rough groups:
	 <ul>
		<li>There's the purely epistemic-logic stuff: the $\square_a
		\phi$ modality which means "agent $a$ believes proposition
		$\phi$", and the common-knowledge $\square_A^* \phi$ which
		represents "every agent in the set $A$ believes
		$\phi$, <I>and</I> they believe every agent in the set believes
		$\phi$, and they believe they believe they believe $\phi$, etc."
		I'm pretty sure this can be handled with a suitably indexed
		Pfenning-Davies box modality, or a variant of it without
		reflexivity and transitivity
		via <a href="http://jcreed.org/papers/linear-modal.pdf">some
		focal encoding of modal logic</a>.
		<li>There's the ordinary dynamic logic stuff, which I am going to talk about below.
		<li>Then there's the really fascinating features that are
		  actually what this paper is mostly about &mdash; namely the
		  belief-update "agent $a$ suspects action $\alpha$" actions. I
		  don't think I'm going to be able to say much about this yet.
	 </ul>
	 <p/>
	 So the point of dynamic logic is that you have some type of <I>actions</I> $\alpha$, for which you can talk about
	 the proposition of $[\alpha]\phi$, thought of as meaning "$\phi$ is true after action $\alpha$ is completed". More
	 specifically, it means that <I>for any way of completing $\alpha$</I>, the proposition $\phi$ will be true afterwards.
	 <p/>
	 Right away we can start by defining some trivial actions,
	 \[\alpha ::= 0 \celse 1 \celse \cdots \]
	 with the intended meaning that $0$ is the action that's impossible to complete, and $1$ is the action
	 that has exactly one way to complete, and has no side-effects on the world at all. This would mean
	 that always
 	 \[ \prov [0]\phi \]
	 (for, indeed, for all ways of completing the action $0$, of which there are none, it's vacuously true that $\phi$)
	 and
 	 \[  [1]\phi  \prequiv \phi\]
	 We can also introduce a nondeterministic action
	 \[\alpha ::= \cdots \celse \alpha \cup \beta \celse \cdots \]
	 and we'd expect that
	 \[ [\alpha \cup \beta] \phi \prequiv [\alpha]\phi \land [\beta]\phi \]
	 In other words: for $\phi$ to be guaranteed to be true after a
	 process that might do $\alpha$, and might do $\beta$, is the same
	 as a guarantee that it's true in the event that $\alpha$ actually
	 happens, and a guarantee that it's true after $\beta$.
	 <p/>
	 There's also a notion of <I>sequencing</I> of actions:
	 \[\alpha ::= \cdots \celse \alpha \cdot \beta \celse \cdots \]
	 The intended meaning of $\alpha \cdot \beta$ is "do $\alpha$, and then do $\beta$". We'd expect the equivalence
	 \[[\alpha \cdot \beta]\phi\prequiv [\beta ][ \alpha]\phi \]
	 <p/>
	 Finally, we want to introduce a way for actions to interact with truth of propositions.
	 There is a <I>test action</I>
	 \[\alpha ::= \cdots \celse ? \phi  \]
	 with the intended semantics that the action $? \phi$ can complete (and has no
	 side effects) only if $\phi$ is currently <I>true</I>.

	 <h2>Semantics</h2>
	 The complete syntax of propositions and actions might then look like
	 \[\phi ::= \top \celse \bot \celse \phi \lor \phi \celse \phi \land \phi \celse \phi \imp \phi \celse [\alpha]\phi \celse p \]
	 \[\alpha ::= 1 \celse 0 \celse \alpha \cup \alpha \celse \alpha \cdot \alpha \celse ? \phi \celse \pi \]
	 where we include some atomic propositions $p$ and atomic actions $\pi$ to go at the leaves of the expression trees.
	 We want to define a translation of this source language into a more low-level ambient metalogic that we can think
	 of a focused proof-theory, and derive some judgmental-looking inference rules for $[\alpha]\phi$.
	 <p/>

	 This translation will be essentially a Kripke-style possible-world
	 semantics. We have a notion of worlds $u, v, w$, and the
	 translation takes in a proposition $\phi$ and a world $u$, and
	 spits out a metalanguage proposition. I'm going to write the
	 metalanguage propositional connectives as $\forall, \exists, \lor,\land,\imp,$
	 etc. and hope that no confusion arises from this overloading.

	 <p/>
	 I'll write this translation as $\phi \wat u$.
	 Let's jump right in and give a translation of $[\alpha]\phi$; we say that the meaning of it is given by
	 \[ ([\alpha]\phi) \wat u = \forall v . R_\alpha(u, v) \imp (\phi \wat v) \]
	 to make sense of this, we have to define $R_\alpha$, takes an action $\alpha$, and two
	 worlds $u$ and $v$, and spits out a metalanguage proposition. We define it recursively on $\alpha$, as follows:
	 \[R_\pi(u, v) = \pi(u, v)\]
	 \[R_{\alpha \cdot \beta}(u, v) = \exists w . R_\alpha(u, w) \land R_\beta(w, v)\]
	 \[R_{\alpha \cup \beta}(u, v) = R_\alpha(u, v) \lor R_\beta(u, v)\]
	 \[R_{1}(u, v) = u = v\]
	 \[R_{0}(u, v) = \bot\]
	 \[R_{? \phi}(u, v) = \phi \land (u = v)\]
	 where we postulate that every atomic action $\pi$ comes equipped
	 with some metalanguage binary relation $\pi(u, v)$ on worlds. The
	 interpretation of every other proposition besides $[\alpha]\phi$
	 (even implication! the Kripke semantics is not here to reify the
	 possible worlds of constructivism itself, but another layer on top
	 of a logic already assumed constructive) is just a boring
	 homomorphism:
	 \[ \top \wat u = \top \qquad \bot \wat u = \bot\]
	 \[ (\phi \land \psi) \wat u = \phi \wat u \land \psi \wat u\]
	 \[ (\phi \lor \psi) \wat u = \phi \wat u \lor \psi \wat u\]
	 \[ (\phi \imp \psi) \wat u = \phi \wat u \imp \psi \wat u\]
	 \[ p \wat u = p(u)\]
	 We do assume that every atomic proposition $p$ comes equipped with a metalanguage unary proposition
	 $p(u)$ on worlds.

	 <h2>Dreaming Up Syntax</h2>

	 So, having written down a "syntactic semantics", we imagine what
	 range of phenomena can possibly occur if we start with a
	 proposition $\phi$, compute $\phi \wat u$, and try to do proof
	 search on the result. Well, if $\phi$ is of the form $[\alpha_1 \cdot \alpha_2 \cdots \alpha_n]\phi$,
	 then we find
	 \[ ([\alpha_1 \cdot \alpha_2 \cdots \alpha_n]\phi) \wat u \equiv
	 (\exists w_1\cdots w_n. R_{\alpha_1}(u, w_1) \land \cdots \land R_{\alpha_n}(w_{n-1}, w_n)) \imp \phi \wat w_n\]
	 Or, up to logical equivalence, we could have also written
	 \[ ([\alpha_1 \cdot \alpha_2 \cdots \alpha_n]\phi) \wat u \equiv
	 \forall w_1\cdots w_n. R_{\alpha_1}(u, w_1) \imp \cdots \land R_{\alpha_n}(w_{n-1}, w_n) \imp \phi \wat w_n\]
	 This means that when we have a proposition like $[\alpha_1 \cdot \alpha_2 \cdots \alpha_n]\phi$ on the
	 right of a sequent, we will need to asynchronously unpack it into a whole sequence of information
	 about possible worlds and actions that transition between them. We therefore guess
	 that the general form of the sequent of the source language is
	 \[\Gamma; \Sigma \prov \phi \]
	 for $\Gamma$ being as usual a context of hypothesized propositions, and $\Sigma$ being a list of actions.
	 Semantically, we say that the meaning of such a judgment is given by
	 \[(\Gamma; \alpha_1, \ldots, \alpha_n \prov \phi)= \]
\[\forall u . \forall w_1\cdots w_n. R_{\alpha_1}(u, w_1) \imp \cdots \land R_{\alpha_n}(w_{n-1}, w_n) \imp \Gamma \wat u \imp \phi \wat w_n \]
	 If $\Gamma$ only consists of hypotheses of the form $\phi\ \mathsf{true}$,
	 then $\Gamma \wat u$ is just the conjunction of $\phi \wat u$. But we will want to have some notion of validity
	 to judgmentally capture how hypotheses are 'prepared' to take action-transitions into future worlds.
	 <p/>
	 We want to do this in such a way that the left rule for the
	 connective $[\alpha]$ doesn't really do anything semantically, but
	 merely transitions from one syntactic expression to another of the
	 same underlying semantic fact. Therefore we introduce the notion that a hypothesis in $\Gamma$
	 can be of the form $\phi\ \mathsf{valid}_\Sigma$, with the meaning
	 \[ (\phi\ \mathsf{valid}_{\alpha_1, \ldots, \alpha_n}) \wat u =
\forall w_1\cdots w_n. R_{\alpha_1}(u, w_1) \imp \cdots \land R_{\alpha_n}(w_{n-1}, w_n) \imp \Gamma \wat u \imp \phi \wat w_n\]
  </body>
  <script>
	 renderMathInElement(
    document.body,
    {
    delimiters: [
    {left: "$$", right: "$$", display: true},
    {left: "\\[", right: "\\]", display: true},
    {left: "$", right: "$", display: false},
    {left: "\\(", right: "\\)", display: false}
    ],
    macros: {
    "\\R": "\\mathbb{R}",
    "\\rset": "\\mathbf{Set}",
    "\\rctx": "\\mathop\\mathsf{ctx}",
    "\\x": "\\times",
    "\\prov": "\\vdash",
    "\\tensor": "\\otimes",
    "\\lol": "\\multimap",
	 "\\rtype": "\\mathsf{type}",
	 "\\dns": "{\\downarrow}",
	 "\\ups": "{\\uparrow}",
	 "\\celse": "{\\ |\\ }",
	 "\\tri": "\\triangleright",
	 "\\imp": "\\Rightarrow",
	 "\\C": "\\mathbf{C}",
	 "\\D": "\\mathbf{D}",
	 "\\PP": "\\mathbf{P}",
	 "\\NN": "\\mathbf{N}",
	 "\\op": "\\mathrm{op}",
	 "\\dash": "-",
	 "\\o": "\\circ",
	 "\\ll": "[\\![",
	 "\\rr": "]\\!]",
    "\\wat": "\\mathop{@}",
    "\\prequiv": "\\dashv\\vdash",
    }
    }
    );
  </script>
</html>
